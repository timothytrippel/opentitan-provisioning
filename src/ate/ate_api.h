// Copyright lowRISC contributors (OpenTitan project).
// Licensed under the Apache License, Version 2.0, see LICENSE for details.
// SPDX-License-Identifier: Apache-2.0
#ifndef OPENTITAN_PROVISIONING_SRC_ATE_ATE_API_H_
#define OPENTITAN_PROVISIONING_SRC_ATE_ATE_API_H_
#include <stddef.h>
#include <stdint.h>

#include <string>
#ifdef __cplusplus
extern "C" {
#endif

#ifndef DLLEXPORT
#ifdef _WIN32
#define DLLEXPORT __declspec(dllexport)
#else  // not _WIN32
#define DLLEXPORT
#endif  // _WIN32
#endif  // DLLEXPORT

enum {
  /** Maximum number of bytes allowed in the SKU specific section of the Device
     Identifier.  */
  kSkuSpecificSize = 16,
  /** Maximum token size in bytes. This is equivalent to 256 bits. */
  kTokenMaxSize = 32,
  /** Maximum wrapped seed size in bytes. This is equivalent to the size of a
     cyphertext generated by RSA */
  kWrappedSeedMaxSize = 384,
};

/**
 * ate_client_ptr is an opaque pointer to an AteClient instance.
 */
typedef struct {
} * ate_client_ptr;

typedef struct {
  // Endpoint address in IP or DNS format including port number. For example:
  // "localhost:5000".
  const char* pa_socket;

  // File containing the Client certificate in PEM format. Required when
  // `enable_mtls` set to true.
  const char* pem_cert_chain;

  // File containing the Client secret key in PEM format. Required when
  // `enable_mtls` set to true.
  const char* pem_private_key;

  // File containing the Server root certificates in PEM format. Required when
  // `enable_mtls` set to true.
  const char* pem_root_certs;

  // SKU authentication tokens. These tokens are considered secrets and are
  // used to perform authentication at the client gRPC call level.
  const char* sku_tokens;

  // Set to true to enable mTLS connection. When set to false, the connection
  // is established with insecure credentials.
  bool enable_mtls;
} client_options_t;

/**
 * The device_id_t is a struct of data passed from secigen to ATE.
 * keep fields 4-bytes aligned.
 */
#pragma pack(push, 1)
typedef struct HardwareOrigin {
  uint16_t silicon_creator_id;
  uint16_t product_id;
  uint64_t device_identification_number;
} hardware_origin_t;

typedef struct DeviceId {
  hardware_origin_t hardware_origin;
  uint8_t sku_specific[kSkuSpecificSize];
  uint32_t crc32;
} device_id_t;
#pragma pack(pop)

/**
 * Hash types supported by the provisioning service.
 */
typedef enum hash_type {
  /** Hash type SHA256. */
  kHashTypeSha256 = 1,
} hash_type_t;

/**
 * Curve types supported by the provisioning service.
 */
typedef enum curve_type {
  /** Curve type P256. */
  kCurveTypeP256 = 1,
} curve_type_t;

/**
 * Signature encoding types supported by the provisioning service.
 */
typedef enum signature_encoding {
  /** Signature encoding DER. */
  kSignatureEncodingDer = 1,
} signature_encoding_t;

/**
 * Request parameters for endorsing certificates.
 */
typedef struct endorse_cert_request {
  /** Hash mechanism. */
  hash_type_t hash_type;
  /** ECC Curve type. */
  curve_type_t curve_type;
  /** Signature encoding type. */
  signature_encoding_t signature_encoding;
  /** Signing key label. */
  const char* key_label;
  /** Size of the TBS data. */
  size_t tbs_size;
  /**
   * TBS data to sign.
   *
   * This field should be allocated by the caller to store the TBS data.
   */
  const char* tbs;
} endorse_cert_request_t;

/**
 * Response parameters for endorsing certificates.
 */
typedef struct endorse_cert_response {
  /**
   * The size of the buffer pointed by `cert`. The user should set the size
   * allocated before calling the `EndorseCerts()` function. The funtion will
   * update the value with the actual certificate size.
   */
  size_t size;
  /**
   * The endorsed certificate.
   */
  char* cert;
} endorse_cert_response_t;

/**
 * Token seed type. The seed is provisioned by the manufacturer.
 */
typedef enum token_seed {
  /** Low security seed. This seed is rotated infrequently. */
  kTokenSeedSecurityLow = 1,
  /** High security seed. This seed is rotated frequently. */
  kTokenSeedSecurityHigh = 2,
} token_seed_t;

/**
 * Token type.
 */
typedef enum token_type {
  /** Raw plaintext token. */
  kTokenTypeRaw = 1,
  /** cSHAKE128 with the "LC_CTRL" customization string. */
  kTokenTypeHashedLcToken = 2,
} token_type_t;

/**
 * Token size.
 */
typedef enum token_Size {
  /** 128-bit token size. */
  kTokenSize128 = 16,
  /** 256-bit token size. */
  kTokenSize256 = 32,
} token_size_t;

/**
 * Derive token parameters.
 */
typedef struct derive_token_params {
  /** Token seed. */
  token_seed_t seed;
  /** Token type. */
  token_type_t type;
  /** Token size. */
  token_size_t size;
  /**
   * Diversifier used during token calculation. Unused bytes should be filled
   * with zeroes.
   */
  uint8_t diversifier[48];
} derive_token_params_t;

/**
 * Generate token parameters.
 */
typedef struct generate_token_params {
  /** Token type.  */
  token_type_t type;
  /** Token size. */
  token_size_t size;
  /**
   * Diversifier used during token calculation. Unused bytes should be filled
   * with zeroes.
   */
  uint8_t diversifier[48];
} generate_token_params_t;

/**
 * Token.
 */
typedef struct token {
  /** Token size in bytes. */
  size_t size;
  /** Token data. */
  uint8_t data[kTokenMaxSize];
} token_t;

typedef struct wrapped_seed {
  size_t size;
  uint8_t seed[kWrappedSeedMaxSize];
} wrapped_seed_t;

/**
 * DeviceLifeCycle encodes the state of the device as it is being manufactured
 * and provisioned for shipment.
 */
enum DeviceLifeCycle : uint32_t {
  DEVICE_LIFE_CYCLE_UNSPECIFIED = 0,  // default -- invalid in messages
  DEVICE_LIFE_CYCLE_RAW = 1,
  DEVICE_LIFE_CYCLE_TEST_LOCKED = 2,
  DEVICE_LIFE_CYCLE_TEST_UNLOCKED = 3,
  DEVICE_LIFE_CYCLE_DEV = 4,
  DEVICE_LIFE_CYCLE_PROD = 5,
  DEVICE_LIFE_CYCLE_PROD_END = 6,
  DEVICE_LIFE_CYCLE_RMA = 7,
  DEVICE_LIFE_CYCLE_SCRAP = 8,
};

/**
 * Creates an AteClient instance.
 *
 * The client instance should be created once and reused many times over a
 * long running session.
 *
 * @param client A pointer (an `ate_client_ptr`) to the created client instance.
 * @param options The secure channel attributes.
 */
DLLEXPORT void CreateClient(ate_client_ptr* client, client_options_t* options);

/**
 * Destroys an AteClient instance.
 *
 * @param client A client instance.
 */
DLLEXPORT void DestroyClient(ate_client_ptr client);

/**
 * initialize session for specific sku.
 *
 * @param client A client instance.
 * @param sku The SKU of the product to initialize for.
 * @param sku_auth The SKU auth.
 * @return The result of the operation.
 */
DLLEXPORT int InitSession(ate_client_ptr client, const char* sku,
                          const char* sku_auth);

/**
 * close session for specific sku.
 *
 * @param client A client instance.
 * @return The result of the operation.
 */
DLLEXPORT int CloseSession(ate_client_ptr client);

/**
 * Derive tokens.
 *
 * The function derives tokens based on the request parameters.
 * The caller should allocate enough memory to store the result.
 *
 * @param client A client instance.
 * @param sku The SKU of the product to derive the keys for.
 * @param count The number of tokens to derive.
 * @param params The parameters for the token derivation.
 * @param[out] keys The derived tokens. Size `count`.
 * @return The result of the operation.
 */
DLLEXPORT int DeriveTokens(ate_client_ptr client, const char* sku, size_t count,
                           const derive_token_params_t* params,
                           token_t* tokens);

/**
 * Generate tokens.
 *
 * The function generates tokens based on the request parameters.
 * The caller should allocate enough memory to store the generated tokens and
 * wrapped seeds.
 *
 * @param client A client instance.
 * @param sku The SKU of the product to generate the keys for.
 * @param count The number of tokens to generate.
 * @param params The parameters for the token generation.
 * @param[out] tokens The generated tokens. Size `count`.
 * @param[out] seed The wrapped seed. Size `count`.
 * @return The result of the operation.
 */
DLLEXPORT int GenerateTokens(ate_client_ptr client, const char* sku,
                             size_t count,
                             const generate_token_params_t* params,
                             token_t* tokens, wrapped_seed_t* seeds);

/**
 * Endorse certificates.
 *
 * The function endorses certificates based on the request parameters.
 *
 * The `certs` parameter should be allocated by the caller to store the
 * endorsed certificates, and each `cert.size` field should represent the
 * allocated size of the `cert.cert` buffer.
 *
 * @param client A client instance.
 * @param sku The SKU of the product to endorse the certificates for.
 * @param cert_count The number of certificates to endorse.
 * @param request The request parameters for the certificate endorsement.
 * @param[out] certs The endorsed certificates.
 * @return The result of the operation.
 */
DLLEXPORT int EndorseCerts(ate_client_ptr client, const char* sku,
                           size_t cert_count,
                           const endorse_cert_request_t* request,
                           endorse_cert_response_t* certs);

#ifdef __cplusplus
}
#endif
#endif  // OPENTITAN_PROVISIONING_SRC_ATE_ATE_API_H_
